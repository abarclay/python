#!/bin/sh

# Below, see a sample of /var/log/messages.
#
# ---------- begin sample log extract ----------
# Jan 20 03:25:08 fakehost logrotate: ALERT exited abnormally with [1]
# Jan 20 03:25:09 fakehost run-parts(/etc/cron.daily)[20447]: finished logrotate
# Jan 20 03:26:21 fakehost anacron[28969]: Job 'cron.daily' terminated
# Jan 20 03:26:22 fakehost anacron[28969]: Normal exit (1 job run)
# Jan 20 03:30:01 fakehost CROND[31462]: (root) CMD (/usr/lib64/sa/sa1 1 1)
# Jan 20 03:30:01 fakehost CROND[31461]: (root) CMD (/var/system/bin/sys-cmd -F > /dev/null 2>&1)
# Jan 20 05:03:03 fakehost ntpd[3705]: synchronized to time.faux.biz, stratum 2
# Jan 20 05:20:01 fakehost rsyslogd: [origin software="rsyslogd" swVersion="5.8.10" x-pid="20438" x-info="http://www.rsyslog.com"] start
# Jan 20 05:22:04 fakehost cs3[31163]:  Q: ".../bin/rsync -LD ": symlink has no referent: "/var/syscmds/fakehost/runit_scripts/etc/runit/service/superImportantService/run"#012Q: ".../bin/rsync -LD ": rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1039) [sender=3.0.6]
# Jan 20 05:22:04 fakehost cs3[31163]:  I: Last 2 quoted lines were generated by "/usr/local/bin/rsync -LD --recursive --delete --password-file=/var/syscmds/modules/rsync_password /var/syscmds/fakehost syscmds@fakehost::syscmds_rsync"
# Jan 20 05:22:08 fakehost cs3[31163]:  Q: ".../sbin/sv restart": ok: run: /export/service/cool-service: (pid 32323) 0s
# Jan 20 05:22:08 fakehost cs3[31163]:  I: Last 1 quoted lines were generated by "/sbin/sv restart /export/service/cool-service"
# Jan 20 05:22:09 fakehost cs3[31163]:  R: cs3:  The cool service on fakehost does not appear to be communicating with the cool service leader.  Automating a restart of the cool service in attempt to resolve the communication problem.
# Jan 20 05:22:37 fakehost ACCT_ADD: WARNING: Manifest /var/syscmds/inputs/config-general/doit.txt has been processed already, bailing
# ---------- end sample log extract ----------
#
# Write a script which parses /var/log/messages and generates a CSV that looks like the following
#
# ---------- begin sample output ----------
# minute,total_messages,logrotate,run-parts,anacron,CROND,ntpd,rsyslogd,cs3,ACCT_ADD
# Jan 20 03:25,22,1,2,3,3,2,0,7,4
# Jan 20 03:26,2,0,0,0,0,0,0,0,2
# Jan 20 03:30,20,9,8,3,0,0,0,0,0
# Jan 20 05:03,10,4,6,0,0,0,0,0,0
# ---------- end sample output ------------

# NOTE: that the list of programs is not fixed, but needs to be dynamicly
# generated

# AWB NOTES: Again with bash here. Probably should have used python
# but again, I felt like stopping to google something would have been
# frowned upon

# I accidentally deleted my solution
# but it looked something like this

# get program names first
cat messages |while read month day mytime hostname program
do
	# pretty sure my solution had incorrect regex
	# would have found that if I could run the program
	# I actually sat at a shell prompt for about 2 minutes
	# running several commands before I got the regex right
	# echo "hello[1123]" |sed -e "s/\([^[]*\)/\1/"
	# echo "hello[1123]" |sed -e "s/\([^[]*\).*/\1/"
	# echo "hello[1123]" |sed -e "s/\([^[:(]*\).*/\1/"
	# echo "hello[1123]" |sed -e "s/\([^[:\( ]*\).*/\1/"
	# echo "hello[1123]" |sed -e "s/\([^[: ]*\).*/\1/"
	# echo "hello[1123]" |sed -e "s/\([^:([]*\).*/\1/"
	#  As it turns out, when you have "[" in a class of
	#  characters, it has to be last character in the class
	#  or sed throws an error about unbalanced brackets
	#echo $program
	echo "$program" |sed -e "s/\([^ :([]*\).*/\1/"
done |sort -u >/tmp/pnames

# exit 5
# ok, pnames has all the program names now - but there are dups
# so added the sort -u above

# add header to output
/bin/echo -n "minute,total_messages" >/tmp/out
cat /tmp/pnames |while read pname
do
	/bin/echo -n ",$pname"
done >>/tmp/out

# notice how I use exit every so often to stop and verify I have what I
# need in the files
#exit 5
# in this case, I found that I had neglected to add the final newline
# to the header
echo >>/tmp/out

cat /dev/null >/tmp/processed

# now, copy from question 3 to get the time
cat messages |while read month day mytime hostname program
do
  newtime=`echo $mytime |sed -e "s/\([^:]*:[^:]*\):.*/\1/"`
  # missed this in my original solution and ended up with dup time lines
  #if we have already processed this timestamp, just continue
  if grep "^$month $day $newtime" /tmp/processed >/dev/null
  then
	continue
  fi
  echo "$month $day $newtime" >>/tmp/processed

  # for each pname count the messages at each minute
  /bin/echo -n "$month $day $newtime" >>/tmp/out
  total=0
  # had to switch from the cat |while because that creates a subshell
  # and the running total doesn't survive
  while read pname
  do
  	count=`cat messages |
		grep "^$month $day $newtime:[0-9]* [^ ]* $pname[ :([].*" |
		wc -l`
	# when I actually ran this, I ended up with a space in front
	# of each of the counts - because they were strings returned
	# by wc... I think adding 0 will fix it
	count=`expr $count + 0`
	total=`expr $total + $count`
	/bin/echo -n ,$count
  done </tmp/pnames >/tmp/counts
  /bin/echo -n ,$total >>/tmp/out
  cat /tmp/counts >>/tmp/out
  echo >>/tmp/out
done
 
cat /tmp/out
# at this point I was done, but the proctor mentioned I forgot total
# messages - Again, I WOULD have noticed this if I could run the
# program

# proctor asked what would happen if messages changed during operation
# I said I could make a copy of messages first
# he said what if it was 10GB
# clearly, proctor wanted this done in a single pass
# I should have used associative arrays but again, didn't want to stop
# to google. I know I would have had to declare the array, then use it

# improving performance as above sounds more like a refactor
# something I didn't have time to do in the short, 1 hour test
